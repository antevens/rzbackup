#!/bin/bash
set -e

# Any files created without specific permissions get read only for user
# results in 400 permissions where even owner
# can't change files
umask 0277

# Timestamp, the date/time we started
start_time=$(date +"%Y-%m-%d-%H-%M")

# Hostname
hostname="`/bin/hostname`"
domainname=`/bin/hostname | /bin/sed -n 's/[^.]*\.//p' || /bin/dnsdomainname 2> /dev/null`

# Constants
default_password_file='/etc/zbackup.pwd'
default_source_dir='/'
default_remote_user=$hostname
default_remote_host="backup.${domainname}"
default_remote_dir="/home/${hostname}"

# Variables
password_file=$default_password_file
source_dir=$default_source_dir
remote_user=$default_remote_user
remote_host=$default_remote_host
remote_dir=$default_remote_dir

# Color Constants
black='\e[0;30m'
red='\e[0;31m'
green='\e[0;32m'
yellow='\e[0;33m'
blue='\e[0;34m'
magenta='\e[0;35m'
purple=${magenta} # Alias
cyan='\e[0;36m'
white='\e[0;37m'
blank='\e[0m' # No Color

# Colored echo
# takes color and message as parameters, valid colors are listed in the constants section
function color_echo {
        eval color=\$$1
        echo -e "${color}${2}${blank}"
}

# Log start
color_echo "Started at ${start_time}"

# Traps for cleaning up on exit
# Originally from http://www.linuxjournal.com/content/use-bash-trap-statement-cleanup-temporary-files
declare -a on_sig_items

function on_exit()
{
    color_echo magenta "Received SIGEXIT, Cleaning up: $i"
    for i in "${on_sig_items[@]}"; do
	debug 10 "Executing cleanup statement: $i"
      	eval $i
    done
}

function on_break()
{
    color_echo red "Signal receied, unexpected exit"
    for i in "${on_sig_items[@]}"; do
        color_echo red "Executing cleanup statement: $i"
        eval $i
    done
}

function add_on_sig()
{
    local n=${#on_sig_items[*]}
    on_sig_items[$n]="$*"
    if [[ $n -eq 0 ]]; then
        trap on_exit EXIT
	trap on_break INT QUIT TERM
    fi
}

# Verify password file exists, if not then we create one and ask user for
# the secret

if ! [ -f ${password_file} ] ; then
    color_echo green "No password file found, creating ${password_file}"
    read -p "Please enter the shared secret(password) to access backups and perform restore:"
    echo "${REPLY}" > "${password_file}"
    color_echo magenta "Created password file with secret: ${backup_secret}"
fi

# Verify zbackup and sshfs are installed, if not we run install
if ! [ -f '/usr/bin/sshfs' ] && [ -f '/usr/bin/zbackup' ]; then
    `/bin/pwd`/rzinstall
fi

# Create secure temporary directory for mount point
tmp_dir="`/bin/mktemp -d`"

# Set signal handler to clean up directory on signal/exit but only if it's
# empty as it should be if unmount was successful
add_on_sig rmdir ${tmp_dir}

# Mount fuse sshfs filesystem
# Automaticaly unmount ssh fuse filesystem on signal/exit
/usr/bin/sshfs ${remote_user}@${remote_host}:${remote_dir} ${tmp_dir} && add_on_Sig /bin/fusermount -u ${tmp_dir}

# Verify zbackup structure exists in remote/target directory
if ! [ -d "${tmp_dir}/backups" ] && [ -d "${tmp_dir}/bundles" ] && [ -d "${tmp_dir}/index" ] && [ -f "${tmp_dir}/info" ]; then
    color_echo red "zbackup structure does not exist on remote host or is damaged, try running zbackup manually!"
    exit -1
fi

# Run the restore
cd "${source_dir}"
/usr/bin/zbackup restore --password-file "${password_file}" "${tmp_dir}/backups/${hostname}-${start_time}" | /bin/tar -vx

# Timestamp, the date/time we finished
end_time=$(date +"%Y-%m-%d-%H-%M")

# Log results
color_echo green "Backup restore completed successfully at ${end_time}"

# Verify password file permissions are correct and warn if they are not
if [ "`/usr/bin/stat -c %a ${password_file}`" != '600' ] ; then
    color_echo red "Warning, file permissions on ${password_file} are not 600 (-rw-------) as they should be!"
fi

# Exit gracefully, triggering cleanup including unmount and removal of
# temporary directory
exit 0
