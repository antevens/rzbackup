#!/bin/bash -e
set -e

# Backups are not allowed to change anything
# results in 400 permissions where even owner
# can't change files

umask 0277

# Timestamp, the date/time we started
start_time=$(date +"%Y-%m-%d-%H-%M")

# Hostname
hostname="`/bin/hostname`"
domainname=`/bin/hostname | /bin/sed -n 's/[^.]*\.//p' || /bin/dnsdomainname 2> /dev/null`

# Constants
default_password_file='/etc/zbackup.pwd'
default_source_dir='/'
default_remote_user=$hostname
default_remote_host="backup.${domainname}"
default_remote_dir="/home/${hostname}"

# Variables
password_file=$default_password_file
source_dir=$default_source_dir
remote_user=$default_remote_user
remote_host=$default_remote_host
remote_dir=$default_remote_dir

# Color Constants
black='\e[0;30m'
red='\e[0;31m'
green='\e[0;32m'
yellow='\e[0;33m'
blue='\e[0;34m'
magenta='\e[0;35m'
purple=${magenta} # Alias
cyan='\e[0;36m'
white='\e[0;37m'
blank='\e[0m' # No Color

# Colored echo
# takes color and message as parameters, valid colors are listed in the constants section
function color_echo {
        eval color=\$$1
        /bin/echo -e "${color}${2}${blank}"
        /usr/bin/logger "zbackup: ${2}"
}

# Log start
color_echo "Started at ${start_time}"

# Traps for cleaning up on exit
# Originally from http://www.linuxjournal.com/content/use-bash-trap-statement-cleanup-temporary-files
declare -a on_sig_items

function on_exit()
{
    color_echo magenta "Received SIGEXIT, Cleaning up: $i"
    for i in "${on_sig_items[@]}"; do
	debug 10 "Executing cleanup statement: $i"
      	eval $i
    done
}

function on_break()
{
    color_echo red "Signal receied, unexpected exit"
    for i in "${on_sig_items[@]}"; do
        color_echo red "Executing cleanup statement: $i"
        eval $i
    done
}

function add_on_sig()
{
    local n=${#on_sig_items[*]}
    on_sig_items[$n]="$*"
    if [[ $n -eq 0 ]]; then
        trap on_exit EXIT
	trap on_break INT QUIT TERM
    fi
}

# Verify password file exists
if ! [ -f ${password_file} ] ; then
    color_echo red "Password file not found, make  sure ${password_file} exists and is readable by the backup process"
fi

# Verify password file permissions are correct and warn if they are not
if [ "`/usr/bin/stat -c %a ${password_file}`" != '600' ] ; then
    color_echo red "Warning, file permissions on ${password_file} are not 600 (-rw-------) as they should be!"
fi

# Create secure temporary directory for mount point
tmp_dir="`/bin/mktemp -d`"

# Set signal handler to clean up directory on signal/exit but only if it's
# empty as it should be if unmount was successful
add_on_sig rmdir ${tmp_dir}

# Mount fuse sshfs filesystem
# Automaticaly unmount ssh fuse filesystem on signal/exit
/usr/bin/sshfs ${remote_user}@${remote_host}:${remote_dir} ${tmp_dir} && add_on_Sig /bin/fusermount -u ${tmp_dir}

# Verify zbackup structure exists in remote/target directory
if ! [ -d "${tmp_dir}/backups" ] && [ -d "${tmp_dir}/bundles" ] && [ -d "${tmp_dir}/index" ] && [ -f "${tmp_dir}/info" ]; then
    color_echo red "zbackup structure does not exist on remote host or is damaged, if this is a fresh installatation consider running the install command to create the structure!"
    exit -1
fi

# Runt the backup, time the execution
backup_result="`/usr/bin/time /bin/tar c --exclude={'/proc/*','/sys/*','/tmp/*','/dev/*','/mnt*','/media','/root/*','/selinux/*'} ${source_dir} | /usr/bin/zbackup backup ${tmp_dir}/backups/${hostname}-${start_time} --password-file ${password_file}`"

# Timestamp, the date/time we finished
end_time=$(date +"%Y-%m-%d-%H-%M")

# Log results
color_echo green "Completed successfully at ${end_time}"
color_echo green  $backup_result

# Exit gracefully, triggering cleanup including unmount and removal of
# temporary directory
exit 0
